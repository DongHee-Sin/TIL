# 프로토콜 (protocol)
### 규약/협약/약속
### 프로토콜을 채택하고, 프로토콜에서 정의한 기능을 구현하여 사용하는 것

<br/>

---

<br/>

## 상속 구조의 단점
* 하나의 클래스만 상속이 가능
* 상위 클래스의 메모리 구조를 따라갈 수 밖에 없음 (필요하지 않은 프로퍼티, 메서드도 상속됨)
* 클래스만 사용가능 (참조타입)

<br/>

### 단점의 코드 예시)
```swift
class Bird {
    
    var isFemale = true
    
    func layEgg() {
        if isFemale {
            print("새가 알을 낳는다.")
        }
    }
    
    func fly() {
        print("새가 하늘로 날아간다.")
    }
}


class Eagle: Bird {
    
    // isFamale
    // layEgg()
    // fly()
    
    func soar() {
        print("공중으로 치솟아 난다.")
    }
}


class Penguin: Bird {
    
    // isFamale
    // layEgg()
    
    // fly()       // 상속 구조에서는 펭귄이 어쩔 수 없이 날개됨 ⭐️
    
    func swim() {
        print("헤엄친다.")
    }
}


// struct가 될 수도 없고(클래스로만 구현가능), 무조건 Bird를 상속해야만 함
class Airplane: Bird {
    
    // isFamale
    // layEgg()         // 상속 구조에서는 비행기가 알을 낳게됨 ⭐️
    
    override func fly() {
        print("비행기가 엔진을 사용해서 날아간다")
    }
}


// 플라잉 박물관을 만듦

struct FlyingMuseum {
    func flyingDemo(flyingObject: Bird) {
        flyingObject.fly()
    }
}


let myEagle = Eagle()
myEagle.fly()
myEagle.layEgg()
myEagle.soar()


let myPenguin = Penguin()
myPenguin.layEgg()
myPenguin.swim()
myPenguin.fly()     // 문제 ===> 펭귄이 날개 됨(무조건적인 멤버 상속의 단점)


let myPlane = Airplane()
myPlane.fly()
myPlane.layEgg()         // 문제 ===> 비행기가 알을 낳음



let museum = FlyingMuseum()     // 타입 정의 ===> 오직 Bird 클래스 밖에 안됨
museum.flyingDemo(flyingObject: myEagle)
museum.flyingDemo(flyingObject: myPenguin)
museum.flyingDemo(flyingObject: myPlane)    // Bird를 상속해야만 사용 가능
```

<br/>

---

<br/>

## 상속구조의 단점을 해결하기 위해 프로토콜을 사용
* 특정 동작을 따로 분리하여, 상속을 하지 않고도 사용 가능하게 만들 수 있음
* 클래스가 아닌, 구조체에서도 사용 가능
* 여러 프로토콜을 채택할 수 있음

<br/>

```swift
// 프로토콜 정의
protocol CanFly {
    // 구체적인 구현은 하지 않음 ==> 메서드의 이름, 매개변수, 반환타입까지만 작성
    func fly()
}

// 상위 클래스
class Bird {
    
    var isFemale = true
    
    func layEgg() {
        if isFemale {
            print("새가 알을 낳는다.")
        }
    }

}


class Eagle: Bird, CanFly {
    
    // isFemale
    // layEgg()
    
    func fly() {
        print("독수리가 하늘로 날라올라 간다.")
    }
    
    func soar() {
        print("공중으로 활공한다.")
    }
}


class Penguin: Bird {
    
    // isFemale
    // layEgg()
    
    func swim() {
        print("물 속을 헤엄칠 수 있다.")
    }
}


// 구조체에서 채택도 가능
struct Airplane: CanFly {
    func fly() {
        print("비행기가 날아간다")
    }
}



// 박물관을 만듦

struct FlyingMuseum {
    // 중요한 기능 ===> 프로토콜을 타입으로 인식
    func flyingDemo(flyingObject: CanFly) {
        flyingObject.fly()
    }
}



let myEagle = Eagle()
myEagle.fly()
myEagle.layEgg()
myEagle.soar()


let myPenguin = Penguin()
myPenguin.layEgg()
myPenguin.swim()
//myPenguin1.fly()     // 더이상 펭귄이 날지 않음


let myPlane = Airplane()
//myPlane.layEgg()         // 더이상 비행기가 알을 낳지 않음
myPlane.fly()


let museum = FlyingMuseum()
museum.flyingDemo(flyingObject: myEagle)
//museum.flyingDemo(flyingObject: myPenguin)   // CanFly 프로토콜을 채택하지 않아서 날 수 없음
museum.flyingDemo(flyingObject: myPlane)
```

<br/>

---

<br/>

## 프로토콜의 요구사항 종류
### 프로토콜을 채택할 부분에서 구현해야 할 내용을 선언
1. [속성(프로퍼티) 요구사항](#속성프로퍼티-요구사항-정의)
2. [메서드 요구사항 (메서드, 생성자, 서브스크립트)]()

<br/>

---

<br/>

## 속성(프로퍼티) 요구사항 정의
### 변수(var)로만 선언 가능
### get, set 키워드를 통해 읽기/쓰기 여부를 설정 (최소한의 요구사항)
### 저장 프로퍼티, 연산 프로퍼티 모두 구현 가능

<br/>

#### 타입 프로퍼티의 경우, 저장 타입 프로퍼티를 구현할 때에는 무조건 "static" 키워드를 사용 -> 재정의 불가
#### 만약 클래스에서 연산 타입 프로퍼티를 구현할 경우에는 "static", "class"키워드 모두 사용 가능 -> 재정의 가능 여부

<br/>

```swift
// 프로토콜 정의
protocol RemoteMouse {
    
    // 구현 ==> var 저장 프로퍼티, let 저장 프로퍼티, 읽기 연산 프로퍼티, 읽기/쓰기 연산 프로퍼티
    var id: String {get}
    
    // 구현 ==> var 저장 프로퍼티, 읽기/쓰기 연산 프로퍼티
    var name: String {get set}
    
    // ==> 타입 저장 프로퍼티(static)
    // ==> 타입 연산 프로퍼티(class)   - 재정의 가능
    static var type: String {get set}
}


// 프로토콜 채택
struct TV: RemoteMouse {
    
    // 최소 get
    var id: String {
        get {
            return "아이디"
        }
        set {
            // 프로토콜에는 get으로 정의했지만 set으로 구현도 가능 (최소한 get으로 구현하란 뜻)
        }
    }
    
    // 최소 get, set
    var name: String = "삼성티비"
    
    // 타입 저장 프로퍼티는 재정의가 원칙적으로 불가능(static키워드) / (상속은 가능)
    static var type: String = "리모컨"
    
}


// 프로토콜 채택
class IPhone: RemoteMouse {
    var id: String = ""
    
    var name: String = ""
    
    // 타입 연산 프로퍼티로 구현하면 class로 선언 가능 (재정의 가능하도록)
    class var type: String {
        get { return "아이폰" }
        set {}
    }
        
}
```