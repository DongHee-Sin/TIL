# 초기화 (Initialization), 생성자 (Initializer)

* [생성자 구현](#생성자의-구현)
* [멤버와이즈 이니셜라이저](#구조체의-멤버와이즈-이니셜라이저-memberwise-initializer)
* [클래스의 지정생성자와 편의생성자](#클래스의-지정생성자-편의생성자)
* [편의생성자의 사용 이유](#⭐️-편의-생성자를-사용하는-이유)
* [클래스의 상속, 재정의 규칙](#생성자의-상속재정의-규칙)
* [생성자 상속의 예외사항](#지정편의-생성자-상속의-예외사항)

<br/>

---

<br/>

### 초기화 (Initialization) :
* 클래스, 구조체, 열거형의 인스턴스를 생성하는 과정
* 각 타입의 "저장 프로퍼티"에 대한 초기값을 설정하여 인스턴스를 사용 가능한 상태로 만드는 것 (열거형의 경우 case중 하나를 선택하여 생성)

### 생성자 (Initializer) :
* 인스턴스의 모든 저장 프로퍼티의 초기값을 가지게 하는 역할

### 소멸자 (Deinitializer) :
* 인스턴스가 메모리에서 해제되기 직전에 수행할 기능을 정의
* class에만 사용할 수 있다.

<br/>
<br/>

### 초기화의 방법 (저장 프로퍼티에 초기값 넣기)
1. 저장 프로퍼티 선언과 동시에 값 저장
2. 저장 프로퍼티를 옵셔널 변수로 선언 (nil로 자동 초기화)
3. 생성자(init)에서 값 초기화

<br/>

---

<br/>

## 생성자의 구현
```swift
class Color {
    let red: Double
    let green: Double
    let blue: Double
    
    
    // 생성자도 오버로딩(OverLoading)을 지원함
    
    init() {         // ==> 기본생성자(파라미터가 없는 생성자) / 저장 프로퍼티의 기본값을 설정하면 "자동" 구현됨
        red = 0.0
        green = 0.0
        blue = 0.0
    }
    
    init(white: Double) {
        red = white
        green = white
        blue = white
    }
    
    init(red: Double, green: Double, blue: Double) {
        self.red = red
        self.green = green
        self.blue = blue
    }
}
```

<br/>

### 모든 저장 프로퍼티가 값을 가질 수 있는 상황이고, 이니셜라이저를 구현하지 않았다면? 컴파일러는 자동으로 기본 생성자(Default Initializer)를 생성해줌
```swift
var someInstance = someClass()  // 이런식으로 작성이 가능한 이유

// 내부적으로는 아래와 같은 코드
var someInstance = someClass.init()
```

<br/>

---

<br/>

## 구조체의 멤버와이즈 이니셜라이저 (Memberwise Initializer)
#### 구조체는 저장 프로퍼티들이 기본값을 가지고 있더라도, (기본생성자에 추가로)멤버와이즈 이니셜라이저를 자동으로 제공한다.
#### 개발자가 직접 이니셜라이저를 구현하면, 멤버와이즈 이니셜라이저는 제공되지 않는다.
```swift
struct Color {
    var red: Double = 1.0
    var green: Double = 1.0
    var blue: Double
}

// 기본값이 없는 저장 프로퍼티만 초기화하는 멤버와이즈 생성자
let someInstance1 = Color(blue: <#T##Double#>)

// 모든 저장 프로퍼티를 초기화하는 멤버와이즈 생성자
let someInstance3 = Color(red: <#T##Double#>, green: <#T##Double#>, blue: <#T##Double#>)
```

<br/>
<br/>

---
---

<br/>
<br/>

## **구조체(값타입)의 지정생성자 구현**
```swift
struct Color {
    let red, green, blue: Double
    
    init() {      // 구조체는 다른 생성자를 호출하는 방식도 가능 ⭐️
        //red = 0.0
        //green = 0.0
        //blue = 0.0
        self.init(red: 0.0, green: 0.0, blue: 0.0)
    }

    init(white: Double) {    // 구조체는 다른 생성자를 호출하는 방식도 가능 ⭐️
        //red   = white
        //green = white
        //blue  = white
        self.init(red: white, green: white, blue: white)
    }
    
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
}
```
<br/>

### 위 코드는 지정생성자가 다른 지정생성자를 호출하는 방식 (= 편의생성자 방식: but 구조체에는 편의생성자라는 개념이 없긴함)
### 이렇게 작성하면 코드 중복을 막고, 나중에 저장 프로퍼티의 내용이 변경되었을 때 유지보수하기 좋아진다.

<br/>

---

<br/>

## **클래스의 지정생성자, 편의생성자**
```swift
class Color {
    let red, green, blue: Double
    
    // 편의 생성자
    convenience init() {
        self.init(red: 0.0, green: 0.0, blue: 0.0)
        //self.init(white: 0.0)
    }

    // 편의 생성자
    convenience init(white: Double) {
        //red   = white
        //green = white
        //blue  = white
        self.init(red: white, green: white, blue: white)
    }
    
    // 지정 생성자
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
}
```

<br/>

### 편의 생성자는 편리하게 생성하기 위한 서브 생성자 (메인이 아닌) - 상속과 관련
### 지정 생성자(메인)에 의존하는 방식으로 구현 (지정생성자가 저장 프로퍼티 초기화)

<br/>

### 가능한 지정생성자의 개수는 줄이고, 편의생성자에서 지정생성자를 호출하도록 만드는것이 바람직

<br/>

### 편의생성자는 다른 편의생성자 or 지정생성자를 호출해야함 (궁극적으로는 지정생성자를 호출)
<img src="https://docs.swift.org/swift-book/_images/initializerDelegation01_2x.png" width="500" height="300" title="" alt="img"></img>

<br/>

### ☝️ 지정 생성자는 모든 저장 프로퍼티를 초기화해야 하지만, 편의 생성자는 모든 프로퍼티를 (직접)초기화 할 필요가 없다.
#### (but: 프로퍼티 선언과 동시에 값을 초기화하거나 옵셔널 변수로 선언하면 모든 저장 프로퍼티를 초기화하지 않아도 괜찮음)
> 내가 이해하기로는.. 지정생성자는 여러곳에서(편의 생성자에서) 돌려가며 써야되니까 모든 저장 프로퍼티를 초기화하는 코드를 구현해야 하고, 편의생성자에서 지정생성자를 호출해서 사용할 때에는 매개변수로 일부 저장 프로퍼티에 대한 값을 받은 후, 직접 초기화하지 않을 데이터에는 임의의 기본값을 부여하는 방식으로 인스턴스를 생성하려고.. 이렇게 설명되는 것 같다.

<br/>
<br/>

## ⭐️ 편의 생성자를 사용하는 이유
### 클래스는 상속을 지원하므로, 변수가(저장 프로퍼티가) 여러개 이고,
### 여러 지정 생성자를 지원했을때 상속 관계에서 개발자가 실수할 수 있는 여러가지 가능성이 생긴다.
### 따라서, 초기화 과정을 간편하게 만들고,
### 상속관계에서 개발자가 실수할 수 있는 여러 가능성을 배제하기 위한 생성자임 

<br/>

### ==> 즉, 모든 저장 프로퍼티를 초기화하지 않는다면, 편의 생성자를 사용하는 것이 복잡도나 개발자의 실수를 줄일 수 있다.

<br/>

### (모든 저장 프로퍼티를 초기화하는 지정생성자가 있을 때) 모든 저장 프로퍼티를 초기화하지 않고, 인스턴스를 생성할 때에는 편의 생성자로 구현하는 것을 권장함

<br/>
<br/>


## 상속 관계에서의 지정 생성자 & 편의 생성자
```swift
class Aclass {
    var x: Int
    var y: Int
    
    // 지정생성자 - 모든 저장 속성 설정
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    // 편의생성자 - (조금 편리하게 생성) 모든 저장 속성을 설정하지 않음
    convenience init() {
        self.init(x: 0, y: 0)
    }
}


// 상속이 일어나는 경우 ⭐️

class Bclass: Aclass {
    
    // 추가된 저장 프로퍼티
    var z: Int
    
    // Bclass에 대응하는 지정생성자 생성 (지정생성자는 반드시 재정의 필요)
    init(x: Int, y: Int, z: Int) {    // 실제 메모리에 초기화 되는 시점
        self.z = z                 // ⭐️ (필수)
        //self.y = y               // 불가 (메모리 셋팅 전)  - 'self' used in property access 'y' before 'super.init' call
        super.init(x: x, y: y)     // ⭐️ (필수) 상위의 지정생성자 호출 (이떄 힙영역에 상위 클래스에서 상속받은 저장 프로퍼티가 생김)
        //self.z = 7
        //self.y = 7
        //self.doSomething()
    }
    
    convenience init(z: Int) {
        //self.z = 7     //===> self에 접근불가 (메모리 셋팅 전)
        self.init(x: 0, y: 0, z: z)
        //self.z = 7
    }
    
    convenience init() {
        self.init(z: 0)
    }
    
    func doSomething() {
        print("Do something")
    }
}



let a = Aclass(x: 1, y: 1)        // 지정생성자
let a1 = Aclass()                 // 편의생성자


let b = Bclass(x: 1, y: 1, z: 1)  // 지정생성자
let b1 = Bclass(z: 2)             // 편의생성자
let b2 = Bclass()                 // 편의생성자
```

<br/>

---

<br/>

## 생성자의 상속&재정의 규칙
### 지정생성자 / 편의생성자 상속과 재정의 규칙

<br/>

### 생성자는 기본적으로 **상속되지 않고, 재정의 해야함.**
(모든 저장 프로퍼티를 초기화해야 하는데, 상위 클래스에서 구현된 생성자는 하위 클래스에 최적화가 되어있지 않음)
 
 <br/>

### ⚠️ 원칙: 1) 상위 지정생성자, 2) 현재 단계의 저장 프로퍼티를 고려해서 생성자 구현

 <br/>

 ```swift
class Vehicle {
    var numberOfWheels: Int = 4
    
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
    
    // 저장 프로퍼티에 기본값을 제공하고, 생성자를 구현하지 않았으므로 기본생성자가 자동으로 제공된다.
    // init() { }
}


// 상위 클래스의 지정생성자 ⭐️
// init()

class Bicycle: Vehicle {
    
    var name: String
    
    override init() {
        self.name = "자전거"
        super.init()
        numberOfWheels = 2  // super.init()을 통해 상위 클래스의 저장 프로퍼티를 메모리에 올린 후 접근가능
    }
    
}


// 상위 클래스의 지정생성자 ⭐️
// init()

class Hoverboard: Vehicle {
    
    var color: String
    
    // 지정생성자
    init(color: String) {
        self.color = "빨강"
        super.init()
    }
    
    // 편의생성자 : self의 지정생성자 호출
    convenience override init() {
        self.init(color: "노랑")
    }
}
 ```

 <br/>

 ---

 <br/>

 ## 지정/편의 생성자 상속의 예외사항
 ### 지정생성자 자동상속의 경우
 * 저장 프로퍼티가 추가되지 않았거나, 추가되었어도 모두 기본값이 있는 경우
 
<br/>

 ### 편의생성자 자동상속의 경우
 * (상위)지정생성자를 모두 **자동상속**하는 경우
 * (상위)지정생성자를 모두 **재정의**하는 경우

<br/>

### 공식문서 예제
```swift
// 음식
class Food {
    var name: String
    
    init(name: String) {     // 지정생성자
        self.name = name
    }
    
    convenience init() {     // 편의생성자 ===> 지정생성자 호출
        self.init(name: "[Unnamed]")
    }
}



let namedMeat = Food(name: "Bacon")   // namedMeat의 이름은 "Bacon"
namedMeat.name

let mysteryMeat = Food()      // mysteryMeat의 이름은 "[Unnamed]"
mysteryMeat.name


// 상위의 지정생성자 ⭐️
// init(name: String)    지정생성자
// convenience init()    편의생성자


// 레서피 재료
class RecipeIngredient: Food {
    var quantity: Int
    
    init(name: String, quantity: Int) {  // 모든 속성 초기화
        self.quantity = quantity
        super.init(name: name)
    }
    
    override convenience init(name: String) {    // 상위 지정생성자를 편의생성자로 재정의 ===> 지정생성자 호출
        self.init(name: name, quantity: 1)
    }
    
    // convenience init() { }      // 자동 상속 (예외 규칙)
}



let oneMysteryItem = RecipeIngredient()    //  편의생성자
oneMysteryItem.name         // [Unnamed]
oneMysteryItem.quantity     // 1

let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)



// 상위의 지정생성자 ⭐️
// init(name: String, quantity: Int)          지정생성자
// override convenience init(name: String)    편의생성자
// convenience init()                         편의생성자


// 쇼핑아이템 리스트
class ShoppingListItem: RecipeIngredient {
    
    var purchased = false       // 모든 저장속성에 기본값 설정
    
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
    
    // init(name: String, quantity: Int) {}    // 지정생성자 모두 자동 상속
    
    // convenience init(name: String) {}       // 따라서 ====> 편의상속자도 모두 자동 상속됨
    
    // convenience init() {}                   // 따라서 ====> 편의상속자도 모두 자동 상속됨
    
}



// 각 배열의 Element는 클래스의 인스턴스 주소를 가지게 되는것
var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]


breakfastList[0].name
//breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true


for item in breakfastList {
    print(item.description)
}


// 출력결과 ============================

// 1 x Orange juice ✔
// 1 x Bacon ✘
// 6 x Eggs ✘
```