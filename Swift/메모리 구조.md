# 메모리 구조
앱(프로그램)은 보조기억장치에 저장되어 있다가 실행되면 메모리(RAM)에 복사되어 올라가면서 실행된다. <br/>
메모리의 4개 영역에 나누어져서 앱이 올라가게 되는데, 이 영역은 하드웨어적으로 나누어진게 아니라 운영체제가 적절하게 나누어서 관리한다.

<br/>

### 메모리의 영역

* 코드
   * 명령어, 프로그램
   * 프로그램을 동작시키기 위한 모든 코드

* 데이터
   * 전역변수, 타입변수(static/class)
   * 프로그램에서 공통적으로 공유하기 위한 데이터를 저장

* 힙
   * 동적할당 (일반적으로 오래 저장)
   * 크기가 크고, 개발자가 관리할 필요가 있다.

* 스택(LIFO)
   * 함수를 실행하기 위한 임시적 공간
   * 크기가 작고, 자동으로 관리된다. (함수가 종료되면 반환)

<br/>

---

<br/>

## 함수와 메모리
함수가 실행되면 메모리의 스택 영역에는 스택 프레임이라는 공간이 생성된다.<br/>
스택 프레임에는 함수 실행을 위한 반환 주소값, 매개변수, 지역변수 등의 정보가 저장된다.<br/>
함수가 종료되면 스택 프레임은 반환된다.

<br/>

함수 내부에서 함수를 호출하는 경우, 스택 영역에는 처음 호출된 함수의 스택 프레임과 두번째로 호출된 함수의 스택 프레임이 모두 존재하게 된다.<br/>
스택 영역은 LIFO 방식으로 동작해서 가장 마지막에 호출된 함수가 종료되고, 해당 함수의 스택 프레임이 스택에서 제거되면 그 다음 함수가 종료되고 ... 이런 방식으로 스택 프레임이 메모리에서 제거된다.

<br/>

재귀함수가 무한히 호출되어 계속 스택 영역에 스택 프레임이 쌓인다면 결국 스택의 모든 공간을 다 차지한 후 더 이상의 공간이 없을 때 스택 오버 플로우가 발생한다.

<br/>

---

<br/>

## 메서드와 메모리
* 메서드는 인스턴스가 저장되는 메모리공간에 저장되지 않는다.
* 메서드(함수)의 코드 묶음은 메모리의 코드영역에 저장되고, 해당 코드 영역의 메모리 주소는 클래스에(데이터 영역) 저장된다.
* CPU가 코드를 읽다가 인스턴스의 메서드를 실행시키는 코드를 읽게 된다면 다음의 순서로 메서드를 실행한다.
   1. 해당 인스턴스의 메모리 주소로 이동한다. (힙영역)
   2. 인스턴스에 저장된 클래스의 주소로 이동한다. (데이터영역)
   3. 클래스에 저장된 메서드의 메모리주소로 이동한다. (코드영역)
   4. 스택프레임을 생성하고, 함수를 실행시킨다.

<br/>

### 왜 이렇게 동작하는가?
* 각각의 인스턴스가 필요한 메서드의 메모리주소를 모두 저장하고 있으면 비효율적
* 메서드는 결국 실행할 코드의 묶음이기 때문임 (모든 인스턴스가 동일한 코드를 실행 & 매개변수의 차이)

<br/>

### ⚠ 구조체의 경우에는 위 방식과 다르게 동작한다.
구조체의 메서드를 실행하는 코드를 CPU가 만나면, 바로 해당 메서드의 메모리주소로 이동하여 실행시킨다.
* 중간과정이 생략되어 클래스보다 속도가 빠름
* 이렇게 동작하는 이유는 클래스와 다르게 상속이 불가능하기 때문 (아마도 재정의 때문인가..?)
