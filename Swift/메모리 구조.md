# 메모리 구조
앱(프로그램)은 보조기억장치에 저장되어 있다가 실행되면 메모리(RAM)에 복사되어 올라가면서 실행된다. <br/>
메모리의 4개 영역에 나누어져서 앱이 올라가게 되는데, 이 영역은 하드웨어적으로 나누어진게 아니라 운영체제가 적절하게 나누어서 관리한다.

<br/>

### 메모리의 영역

* 코드
   * 명령어, 프로그램
   * 프로그램을 동작시키기 위한 모든 코드

* 데이터
   * 전역변수, 타입변수(static/class)
   * 프로그램에서 공통적으로 공유하기 위한 데이터를 저장
   * 실제로 값에 접근할 때 메모리에 올라오긴 하지만, 앱이 종료되기 전까지 해제되지 않는 사실이 더 중요

* 힙
   * 동적할당 : 영역을 스캔하고, 비어있는 공간을 찾아서 할당 => **속도 저하**
   * 힙 손상 : 이중 해제, 해제 후 사용 등의 작업 => **속도 저하**
   * 힙 경합 : 두 개 이상의 스레드가 동시에 접근하려 할 때 Lock이 걸림 => **속도 저하**
   * 일반적으로 오래 저장하면서 사용할 때 힙에 저장됨
   * 크기가 크고, 개발자가 관리할 필요가 있다.
   * 할당이 해제되지 않으면 메모리 누수가 발생한다.
   * 메모리 크기에 제한이 없다.

* 스택(LIFO)
   * 함수를 실행하기 위한 임시적 공간
   * 크기가 작고, 자동으로 관리된다. (함수가 종료되면 반환)
   * 컴파일 시점에 결정되어 무한히 할당할 수 없다.

<br/>
<br/>

### 스택영역은 메모리가 한정되어 있기 때문에 너무 큰 메모리는 할당할 수 없다.
#### 원래 스택에 저장되어야 하는 데이터라도 값이 너~무 크게 생성된다면? 자동으로 힙에 저장됨 (ex-엄~청 긴 문자열 변수)

<br/>

<span style="color:yellow">데이터 영역은 한번 메모리에 올라오면 앱이 종료되기 전까지 해제할 수 없다.<br/> 때문에 데이터 영역에 너무 많은 데이터가 할당되도록 하면 안됨 (전역변수나 타입 프로퍼티를 너무 많이 사용하는 등)</span>

<br/>

---

<br/>

## 함수와 메모리
함수가 실행되면 메모리의 스택 영역에는 스택 프레임이라는 공간이 생성된다.<br/>
스택 프레임에는 함수 실행을 위한 반환 주소값, 매개변수, 지역변수 등의 정보가 저장된다.<br/>
함수가 종료되면 스택 프레임은 반환된다.

<br/>

함수 내부에서 함수를 호출하는 경우, 스택 영역에는 처음 호출된 함수의 스택 프레임과 두번째로 호출된 함수의 스택 프레임이 모두 존재하게 된다.<br/>
스택 영역은 LIFO 방식으로 동작해서 가장 마지막에 호출된 함수가 종료되고, 해당 함수의 스택 프레임이 스택에서 제거되면 그 다음 함수가 종료되고 ... 이런 방식으로 스택 프레임이 메모리에서 제거된다.

<br/>

재귀함수가 무한히 호출되어 계속 스택 영역에 스택 프레임이 쌓인다면 결국 스택의 모든 공간을 다 차지한 후 더 이상의 공간이 없을 때 **스택 오버 플로우가 발생**한다.

<br/>

---

<br/>

## 메서드와 메모리
* 메서드는 인스턴스가 저장되는 메모리공간에 저장되지 않는다.
* 메서드(함수)의 코드 묶음은 메모리의 코드영역에 저장되고, 해당 코드 영역의 메모리 주소는 클래스에(데이터 영역) 저장된다.
* CPU가 코드를 읽다가 인스턴스의 메서드를 실행시키는 코드를 읽게 된다면 다음의 순서로 메서드를 실행한다.
   1. 해당 인스턴스의 메모리 주소로 이동한다. (힙영역)
   2. 인스턴스에 저장된 클래스의 주소로 이동한다. (데이터영역)
   3. 클래스에 저장된 메서드의 메모리주소로 이동한다. (코드영역)
   4. 스택프레임을 생성하고, 함수를 실행시킨다.

<br/>

### 왜 이렇게 동작하는가?
* 각각의 인스턴스가 필요한 메서드의 메모리주소를 모두 저장하고 있으면 비효율적
* 메서드는 결국 실행할 코드의 묶음이기 때문임 (모든 인스턴스가 동일한 코드를 실행 & 매개변수의 차이)

<br/>

### ⚠ 구조체의 경우에는 위 방식과 다르게 동작한다.
구조체의 메서드를 실행하는 코드를 CPU가 만나면, 바로 해당 메서드의 메모리주소로 이동하여 실행시킨다.
* 중간과정이 생략되어 클래스보다 속도가 빠름
* 이렇게 동작하는 이유는 클래스와 다르게 상속이 불가능하기 때문 (아마도 재정의 때문인가..?)
* ==> 클래스가 상속이 되는 경우 상위 클래스의 메서드 메모리 주소를 하위 클래스가 복사해서 저장하게 된다. (재정의를 하기 위해) 구조체의 경우 상속이 불가능하기 때문에 이런 과정 없이 바로 메서드의 메모리주소로 이동하여 실행한다. (만약 클래스에서 final키워드를 사용하여 상속을 금지하면 구조체와 동일하게 동작함.)
