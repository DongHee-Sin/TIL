# 프로퍼티
### 클래스/구조체에서 상수나 변수로 선언되는 속성

<br/>

---

<br/>

## 저장 프로퍼티 (Stored Property)
* 클래스/구조체 타입으로 생성된 각 인스턴스가 가지는 고유의 데이터 저장 공간
* 변수나 상수로 선언
* 인스턴스의 초기화시, 각 저장 프로퍼티는 반드시 값을 가져야 한다. (Optional타입으로 선언하면 초기화 시점에 nil로 자동 초기화)
```swift
class Person {
   let name: String = "이름"
   var age: Int = 20
}
```

<br/>
<br/>

## 지연 저장 프로퍼티 (Lazy Stored Property)
* lazy 키워드를 변수/상수 앞에 붙여서 사용
* 지연 저장 프로퍼티는 값의 초기화를 지연시킴 (프로퍼티에 접근하는 순간 초기화)
* 해당 속성이 처음부터 초기화가 필요하지 않은 경우 사용함 (ex: 메모리 공간을 많이 차지하는 이미지 등)
* 변수로만 선언 가능 (let X)
* 생성자에서 초기화되지 않기 때문에 반드시 **기본값이 필요함** (기본값은 모든 표현식 사용 가능- 함수, 클로저, 리터럴값 등)

<br/>

### 지연 저장 프로퍼티를 사용하는 이유
* 메모리 공간의 낭비를 막을 수 있음
* 지연 저장 프로퍼티로 선언되는 속성이 다른 저장 프로퍼티를 이용해야하는 경우
```swift
class someClass {
   let a: Int = 10

   // 연산 프로퍼티가 아니라 함수를 실행시키는 형태임
   lazy var b: Int = {
      return a * 10
   }()
}
```

<br/>

---

<br/>

## 연산 프로퍼티 (Computed Property)
* 속성의 형태를 가진 실질적 메서드 (일반적으로 다른 저장 프로퍼티의 값에 의존하여 사용되는 메서드를 속성처럼 만든 것)
* 메서드이기 때문에 인스턴스가 저장된 영역에 메모리 공간이 할당되지 않음

<br/>

### 예시1 )
```swift
class Person {
    
    var birth: Int
    
    init(birth: Int) {
        self.birth = birth
    }
    
    // Computed Property
    var age: Int {
        // 필수
        get {
            return 2022 - birth
        }
        // 선택
        set {
            self.birth = 2022 - newValue
        }
    }
}
 
// 인스턴스 생성
var dong: Person = Person(birth: 1998)

// get
dong.age   // 24

// set
dong.age = 20

// get
dong.age    // 20
dong.birth  // 2002
```

<br/>

### 예시2 ) bmi 계산
```swift
class Person {
    
    var height: Double
    var weight: Double
    
    init(height: Double, weight: Double) {
        self.height = height
        self.weight = weight
    }
    
    var bmi: Double {
        get {
            return weight / (height * height) * 10000
        }
        set(bmi) {
            // 키는 고정이라는 가정
            weight = bmi * height * height / 10000
        }
    }
}

// 인스턴스 생성
var jun: Person = Person(height: 175, weight: 90)

jun.bmi  // 29.387...


jun.bmi = 20
jun.weight    // 61.25
```

<br/>

### 연산 프로퍼티를 사용하는 이유
* 관련있는 두가지 메서드(함수)를 한번에 구현할 수 있음
* 외부에서 사용할 때 프로퍼티 이름으로 접근이 가능하므로 보다 명확해 보임
* so. 연산 프로퍼티는 메서드를 가독성 좋고, 명확하게 사용할 수 있는 형태로 변환한 것

<br/>
<br/>

### 연산 프로퍼티는 겉모습은 프로퍼티(변수)형태를 가졌지만, 실제로는 메서드임
### 때문에 메서드처럼 인스턴스를 저장한 메모리 영역에 공간을 차지하지 않고, 해당 프로퍼티에 접근하면 다른 저장 프로퍼티에 접근해서 계산한 후, 계산 결과를 리턴하거나 세팅하는 메서드
### 메모리에서 동작하는 방식도 메서드와 동일

<br/>
<br/>

### 주의할점
* 변수로만 선언 가능
* 자료형을 반드시 선언 (타입추론 불가능) -> 메서드로 동작하기 때문에 파라미터와 리턴타입이 필요한 것
* get은 필수, set은 선택 (get만 선택하면 get-only-property)

<br/>

---

<br/>

## 타입 프로퍼티 (Type Property)
 * static또는 class 키워드를 붙여서 사용
 * 타입 자체에 속하는 프로퍼티 (Type이름.property 방식으로 접근)
 * [저장](#저장-타입-프로퍼티)/[연산](#연산-타입-프로퍼티) 타입 프로퍼티가 있음
 * 클래스나 구조체가 저장된 메모리 영역에 같이 저장됨 (데이터 영역)
 * 클래스, 구조체, 열거형에 모두 추가 가능
 * 주로 저장 타입 프로퍼티를 많이 사용

 <br/>

 ## 저장 타입 프로퍼티
 * 모든 인스턴스가 동일하게 가져야하는 **보편적인 속성**이나
 * **모든 인스턴스가 공유**해야하는 프로퍼티의 경우 저장 타입 프로퍼티로 선언
* static 키워드를 사용
* 재정의 불가 (class 키워드 사용 불가, 메서드만 상속 가능)
* 항상 기본값(초기값) 필요 -> 생성자에 의한 값 설정 과정이 없기 때문
* **자체적으로 지연(lazy) 프로퍼티의 성격**을 가지므로, 호출할 때 메모리에 할당됨(내부적으로 Thread-Safe처리)

<br/>

## 연산 타입 프로퍼티
* static 또는 class 키워드 사용
* 재정의 가능 (class로 선언했을 때)
* 변수로만 사용 가능 (연산 타입 속성)
* 메서드이므로 메모리 공간이 할당되지 않음 (연산 타입 속성)

<br/>

```swift
class Circle {
    
    // 저장 타입 프로퍼티
    static let pi: Double = 3.14
    static var count: Int = 0
    
    // 연산 타입 프로퍼티 (read-only)
    // 6.28을 리터럴로 넣어주어도 되지만, 메모리공간의 절약 + 코드 가독성(누가봐도 연관된 데이터) 측면에서 연산 프로퍼티로 사용하는게 좋음
    static var multiPi: Double {
        return Circle.pi * 2
    }
    
    // 저장 프로퍼티
    var radius: Double
    
    // 생성자
    init(radius: Double) {
        self.radius = radius
        Circle.count += 1     // 인스턴스가 생성될 때마다 +=1 연산
    }
}

Circle.pi       // 3.14
Circle.multiPi  // 6.28

// 인스턴스 생성
let test = Circle(radius: 1.0)
Circle.count    // 1
```