# 제네릭(Generics)

## 제네릭 문법의 필요성
#### 제네릭이 없다면, 함수(클래스, 구조체, 열거형 등) 타입마다 모든 경우를 다 정의해야 한다.
#### 유지보수/재사용성 관점에서 좋지 않고, 개발자의 일이 늘어난다.
```swift
// 두 숫자를 스왑(서로 교환)하는 함수의 정의
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let tempA = a
    a = b
    b = tempA
}

// => 만약 Int가 아닌 다른 타입을 스왑하고 싶다면?
// 스왑이 필요한 모든 타입에 맞게 함수를 정의해야 한다.
```

<br/>

---

<br/>

## 제네릭 문법
#### 타입에 관계없이, 한번의 구현으로 모든 타입을 처리하는 문법 (타입에 유연한 함수를 작성할 수 있고, 유지보수/재사용성이 좋아진다.)
#### (함수 뿐만 아니라) 클래스, 구조체, 열거형도 제네릭 문법을 사용하여 일반화가 가능하다.
* 제네릭 함수, 제네릭 클래스 ...

<br/>

---

<br/>

## 제네릭 함수의 정의
#### 타입 파라미터 \<T>는 함수 내부에서 파라미터의 타입이나 리턴타입으로 사용됨 (함수 바디에서 사용도 가능)
1. 관습적으로 Type의 의미인 "T"를 사용한다. (다른 이름도 가능 - UpperCamelCase)
2. 타입 파라미터를 2개 이상 선언도 가능 <T, A>
3. 함수 이름 뒤에 사용할 파라미터 타입을 정의해야 한다.
```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let tempA = a
    a = b
    b = tempA
}

// 같은 타입이라면, 어떤한 값도 전달할 수 있다.
swapTwoValues(&string1, &string2)
swapTwoValues(&num1, &num2)
```

<br/>

> 타입 파라미터 : <br/>실제타입 대신 사용하는 "place holder"역할을 한다.<br/>본래 타입이 사용되는 위치에서 타입 파라미터를 사용하여 함수를 구현하고, <br/>실제 함수 호출시에 실제 타입으로 치환된다.

<br/>

### 제네릭의 사용예시
#### Swift의 Collection은 모두 제네릭 구조체로 구현되어 있다.
```swift
// Array
@frozen public struct Array<Element> {
   // 구현 ....
}

// 타입으로 표시
let arr: Array<String> = []



// ========================================================

// Dictionary
// 2개의 타입 파라미터를 사용 => Key, Value
@frozen public struct Dictionary<Key, Value> where Key : Hashable {
   // 구현 .....
}

// 타입으로 표시
let dic: Dictionary<String, Int> = [:]



// ========================================================

// Optional
@frozen public enum Optional<Wrapped> : ExpressibleByNilLiteral {
   // 구현 ....
}

// 타입으로 표시
let optionalValue: Optional<String>
```