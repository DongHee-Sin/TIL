# 동적 계획법 (Dynamic Programming)
#### 메모리를 적절히 사용하여 수행 시간 효율성을 향상시키는 방법으로, 이미 계산된 결과를 별도 메모리에 저장하여 다시 계산하지 않도록 한다.
#### 동적 계획법에 사용된 Dynamic은 런타임 시점에 메모리에 할당되는 "동적 할당"과는 다르게 별다른 의미 없이 사용된 단어

<br/>
<br/>

## 동적 계획법 구현의 방식

### 1) 탑다운 (하향식)
* 재귀함수를 사용
* 큰 문제에 대한 답을 얻기 위해 재귀적으로 작은 문제를 해결하고, 작은 문제의 답을 통해 큰 문제의 답을 얻도록 한다.
* 이 과정에서 해결된 문제들을 **메모이제이션**을 통해 기록한다.

<br/>

### 2) 보텀업 (상향식)
* 반복문을 사용하며, 작은 문제를 먼저 해결해나가는 방법
* 먼저 해결된 문제를 활용하여 다음 문제를 해결한다.
* 동적 계획법의 전형적인 형태는 보텀업 방식으로, 결과 저장용 배열은 **DP Table**이라고 부른다.

<br/>

> [메모이제이션(Memoization)](https://ko.wikipedia.org/wiki/메모이제이션) : <br/>
이전에 계산된 결과를 일시적으로 기록하기 위한 배열 (캐싱이라고도 부른다.)

<br>
<br>

### 동적 계획법의 조건
#### **1. 최적 부분 구조** :
* 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제의 답이 모여서 큰 문제를 해결할 수 있다.
#### **2. 중복되는 부분 문제** :
* 동일한 작은 문제를 반복적으로 해결해야 한다.

<br/>

---

<br/>

## 동적 계획법(DP) 예시
#### 피보나치 수열 계산 (1, 1, 2, 3, 5, 8 ...)

<br/>

### 1) 재귀함수로 구현한 피보나치 수열
* 지수 시간 복잡도를 가진다. O(2^n)
* fibo(2)가 여러 번 호출된다. (중복되는 부분 문제)
```swift
func fibo(_ n: Int) -> Int {
    if n == 1 || n == 2 {
        return 1
    }
    
    return fibo(n-1) + fibo(n-2)
}

print(fibo(4))   // 3
```

<br/>

### 2) 탑다운으로 구현한 피보나치 수열
* 선형 시간복잡도를 가진다. O(n)
* 이미 해결했던 문제를 DP Table에 저장하여 사용
```swift
// 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 배열 초기화
var dpTable: [Int] = Array(repeating: 0, count: 100)

func fibo(_ n: Int) -> Int {
    if n == 1 || n == 2 {
        return 1
    }

    if dpTable[n] != 0 {
        // 이미 계산한 적 있다면 결과값 리턴
        return dpTable[n]
    }else {
        // 계산한 적 없다면 계산하고, DP Table에 저장
        dpTable[n] = fibo(n-1) + fibo(n-2)
    }

    return dpTable[n]
}

print(fibo(10))   // 55
```

<br/>

### 3) 보텀업으로 구현한 피보나치 수열
* 선형 시간복잡도를 가진다. O(n)
* 이미 해결했던 문제를 DP Table에 저장하여 사용
```swift
// 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 배열 초기화
var dpTable: [Int] = Array(repeating: 0, count: 100)

// 작은 문제를 해결하기 위한 초기값 설정
dpTable[1] = 1
dpTable[2] = 1
var n: Int = 10

for i in 3...n {
    dpTable[i] = dpTable[i-1] + dpTable[i-2]
}

print(dpTable[n])
```

<br/>
<br/>

---

<br/>
<br/>

## 동적 계획법 vs 분할 정복

### <공통점>
* 문제를 작은 단위로 분할하여 큰 문제를 해결

<br/>

### <차이점>
#### **동적 계획법 :**
* 작은 단위로 해결된 문제의 해답이 큰 문제를 해결하기 위해 **재사용** 된다.

#### **분할 정복 :**
* 작은 단위로 해결된 문제의 해답이 큰 문제를 해결하기 위해 **재사용되지 않는다**.

<br/>

> [분할 정복](https://namu.wiki/w/분할%20정복%20알고리즘) : <br/>
큰 문제를 조금씩 나눠서 해결한 후 결과를 합쳐서 해결한다는 개념으로, 퀵소트나 병합정렬 등에 사용된다.