# 22.08.05

## Checklist
* Closure의 축약 문법
* Attributes
* 고차함수 (filter, map, reduce)
* 프로그램, 프로세스, 스레드
* 동기/비동기 (feat. DispatchQueue)

<br/>
<br/>

---

<br/>
<br/>

## 클로저의 축약 문법

코드를 생략하지 않은 클로저 구문의 사용 : 인라인(Inline) 클로저 <br/>
in 키워드를 기준으로 클로저 헤더, 클로저 바디가 구분된다.
```swift
let someClosure: (Int) -> String = { (value: Int) -> String in
    return "숫자 : \(value)"
}
```

<br/>

매개변수와 반환값 내용을 생략 <br/>
매개변수 이름은 $0, $1 ... 와 같은 축약인자로 사용한다. <br/>
추가로, 리턴값이 있으면서 1줄의 실행코드만 있는 경우 return 키워드도 생략 가능
```swift
let someClosure: (Int) -> String = {
    "숫자 : \($0)"
}
```

<br/>

## 트레일링 클로저 (후행클로저)
함수의 마지막 매개변수가 클로저인 경우, 함수를 호출할 때 클로저를 밖으로 빼서 작성할 수 있다.
```swift
func someFunction(closure: () -> Void) {
    closure()
}

someFunction {
    print("() <= 같은 함수 실행문 밖에서 클로저를 입력할 수 있다.")
}
```

<br/>

---

<br/>

## Attribute
컴파일러에게 추가적인 정보를 제공하기 위한 키워드 <br/>
선언, 타입, Switch구문의 case 등에 추가적인 정보를 제공할 수 있다. 
* @available : 특정 iOS 버전 이상에서만 사용이 가능하다는 의미
* @discardableResult : 함수의 반환값을 사용하지 않을 수 있다는 의미 (함수의 반환값을 사용하지 않아도 노란색 경고문구가 나오지 않음)
* @propertyWrapper : 프로퍼티가 저장되는 방식을 관리하는 코드와 프로퍼티를 정의하는 코드 사이에 분리계층을 추가하는 목적으로 사용 [정리](https://co-dong.tistory.com/67)
* @escaping : 매개변수로 입력된 클로저가 함수의 실행흐름(스택프레임)을 탈출할 수 있도록 하는 키워드

<br/>

---

<br/>

## 고차함수
매개변수로 함수를 받거나 반환값으로 함수를 사용할 수 있는 함수로, Swift에서 함수가 1급 객체로 사용되기 때문에 고차함수와 같은 형태를 이용할 수 있다. <br/>
일반적으로 클로저 형태를 사용한다. <br/>
고차함수를 사용하면 반복문+조건문이 필요한 연산에서 효율적으로 연산이 가능하다.

<br/>

### map
Collection의 각 아이템을 매핑하여 변형하는 경우에 사용 <br/>
요소의 매핑 방식을 클로저 구문으로 작성하여 매개변수로 입력한다. <br/>
새로운 데이터를 생성하여 반환하며, 기존의 데이터는 변경되지 않는다. <br/>
```swift
let someArray = [1, 2, 3, 4, 5]

let map = someArray.map {
    $0 + 10
}
// [11, 12, 13, 14, 15]
```

<br/>

### filter
Collection의 요소를 순환하면서 조건에 맞는 요소만 추출하여 배열로 반환한다. <br/>
Bool 타입을 반환값으로 가지는 필터링 조건 클로저 구문을 작성한다. <br/>
```swift
let someArray = [1, 2, 3, 4, 5]

let filter = someArray.filter {
    $0 % 2 == 0
}
// [2, 4]
```

<br/>

### reduce
Collection의 각 요소를 결합하여 마지막 결과값을 반환한다. <br/>
2개의 매개변수를 갖는다.
1. 초기값
2. 결합 구문 클로저


```swift
let someArray = [1, 2, 3, 4, 5]

let reduce = someArray.reduce(0) {
    $0 + $1
}
// 15
```
<위 코드의 연산 과정>
1. 0(초기값) + 1 연산 결과 저장
2. 1 + 2 연산 결과 저장
3. 3 + 3 연산 결과 저장
4. 6 + 4 연산 결과 저장
5. 10 + 5 연산 결과 저장
6. 연산 결과 반환

<br/>

---

<br/>

## 프로그램 / 프로세스 / 스레드

### 프로그램
보조기억장치에 저장된 실행 파일을 의미한다. (설치는 되었으나 실행되어 메모리에 올라오지 않은 상태) <br/>

<br/>

### 프로세스
보조기억장치에 저장되어 있던 프로그램이 실행을 위해 메모리에 올라오면 프로세스의 상태가 된다. <br/>
각 프로세스는 OS에게 시스템 자원을 할당받는다.
> OS에게 할당받는 시스템 자원 :
> 1. CPU 시간
> 2. 운영되기 위해 필요한 주소 공간
> 3. 코드, 데이터, 힙, 스택의 구조로 되어있는 독립적인 메모리 공간

각 프로세스는 독립적인 메모리 공간을 가지기 때문에, 다른 프로세스의 메모리에 접근하기 위해서는 프로세스 간의 통신을 사용해야 한다. <br/>
기본적으로 1개 이상의 스레드를 가진다. (메인 스레드)

<br/>

### 스레드
프로세스 내에서 동작되는 여러 실행의 흐름, 실행되는 하나의 작업 단위를 말한다. <br/>
각 스레드는 프로세스의 Code, Data, Heap 메모리 공간은 서로 공유하며 Stack영역만 독립적으로 사용한다. <br/>
Stack영역을 제외한 나머지 자원을 공유하기 때문에 공유자원의 문제가 발생할 수 있다.

<br/>

---

<br/>

## 멀티 스레드
하나의 스레드(main)에서 이루어지던 작업을 다른 스레드에게도 작업을 배분하여 분산 처리하는 것 <br/>
많은 운영체제가 멀티 프로세싱을 지원하지만, ContextSwitching 과정에서 오버헤드가 발생하기 때문에 멀티 스레딩을 많이 사용한다.
> ContextSwitching ? <br/>
> 하나의 프로세스가 CPU 시간을 사용 중인 상태에서 다른 프로세스의 작업을 CPU가 처리하기 위해, 이전 프로세스의 상태를 보관하고 새로운 프로세스 상태를 적재하는 작업을 말한다. <br/>
> CPU는 각 프로세스를 빠르게 Switching하면서 실행시키는데, 프로세스는 메모리가 모두 독립적으로 존재하기 때문에 CPU의 부담이 커지고, 오버헤드가 발생한다.

<br/>

iOS에서는 멀티 스레드 처리를 위해 2가지의 대기열 Queue를 사용한다.
1. DispatchQueue
2. OperationQueue

<br/>

### DispatchQueue (GCD)
비교적 간단하게 사용 가능하며, 클로저를 사용하여 작업 단위를 표현한다.

<br/>

### OperationQueue
GCD를 기반으로 더 많은 기능이 추가된 Queue로 WWDC15에서 처음 발표되었다. <br/>
작업을 취소, 일지중지, 중지된 작업 다시 시작 등 GCD에서 구현할 수 없었던 복잡한 기능을 구현할 수 있다.<br/>
사용이 간편하여 GCD가 일반적으로 많이 사용되지만 OperationQueue의 기능이 필요한 경우에 사용한다.

<br/>

---

<br/>

## 동기/비동기 (GCD)

### DispatchQueue에는 3가지 종류가 있다.
DispatchQueue.main ... (이런 형식으로 사용)
1. main
2. global
3. custom

<br/>

### main
메인스레드를 의미하며, 직렬 방식으로 동작한다. <br/>
메인스레드에서 iOS의 드로잉사이클이 동작하기 때문에 UI 업데이트의 작업은 메인스레드에서만 처리 가능하다.

<br/>

### global
QoS(Quality of Service)를 사용하여 작업 순서에 대한 우선순위를 설정 가능하다.<br/>
기본값이 동시적으로 동작하여 Queue에 입력된 작업을 여러 스레드로 보내서 처리한다. (단, 클로저 구문으로 묶은 작업의 단위는 하나의 스레드로 처리되어 "직렬"로 동작)

<br/>

### custom (private)
개발자가 커스텀으로 생성하는 대기열 Queue로, Qos설정도 가능하다. <br/>
기본값이 직렬로 동작한다.
